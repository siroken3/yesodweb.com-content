<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE concept PUBLIC "-//OASIS//DTD DITA Concept//EN" "concept.dtd">
<concept id="shakespearean-templates-27"><title>Shakespearean Templates</title><conbody>
  <p id="27-x1">Yesod uses the Shakespearean family of template languages as its standard approach to HTML, CSS
   and Javascript creation. This language family shares some common syntax, as well as overarching
    principles:<ul id="27-ul_49ef34dd-2fd1-41b2-9c21-eb1bf09ac57a">
    <li id="27-x2">As little interference to the underlying language as possible, while providing
     conveniences where unobtrusive.</li>
    <li id="27-x3">Compile-time guarantees on well-formed content.</li>
    <li id="27-x4">Static type safety, greatly helping the prevention of <xref href="http://en.wikipedia.org/wiki/Cross-site_scripting" format="html" scope="external">XSS
      (cross-site scripting)</xref> attacks.</li>
    <li id="27-x5">Automated checking of valid URLs, whenever possible, through <term id="27-x6">type-safe
     URLs</term>.</li>
   </ul></p>
  <p id="27-x7">There is nothing inherently tying Yesod to these languages, or the other way around:
   each can be used independently of the other. This chapter will address these template languages
   on their own, while the remainder of the book will use them to enhance Yesod application
   development.</p>
 </conbody><concept id="synopsis-28"><title>Synopsis</title><conbody>
        <p>There are four main languages at play: Hamlet is an HTML templating language, Julius is
            for Javascript, and Cassius and Lucius are both for CSS. Hamlet and Cassius are both
            whitespace-sensitive formats, using indentation to denote nesting. By contrast, Lucius
            is a superset of CSS, keeping CSS's braces for denoting nesting. Julius is a simple
            passthrough language for producing Javascript; the only added feature is variable
            interpolation.</p>
    </conbody><concept id="hamlet-html-29"><title>Hamlet (HTML)</title><conbody>
  <codeblock outputclass="hamlet" id="29-x1">$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle} - My Site
        &lt;link rel=stylesheet href=@{Stylesheet}&gt;
    &lt;body&gt;
        &lt;h1 .page-title&gt;#{pageTitle}
        &lt;p&gt;Here is a list of your friends:
        $if null friends
            &lt;p&gt;Sorry, I lied, you don't have any friends.
        $else
            &lt;ul&gt;
                $forall Friend name age &lt;- friends
                    &lt;li&gt;#{name} (#{age} years old)
        &lt;footer&gt;^{copyright}</codeblock>
 </conbody></concept><concept id="cassius-css-30"><title>Cassius (CSS)</title><conbody>
  <codeblock outputclass="cassius" id="30-x1">#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})</codeblock>
 </conbody></concept><concept id="lucius-css-31"><title>Lucius (CSS)</title><conbody>
  <codeblock outputclass="lucius" id="31-x1">section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}</codeblock>
 </conbody></concept><concept id="julius-javascript-32"><title>Julius (Javascript)</title><conbody>
  <codeblock outputclass="julius" id="32-x1">$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});</codeblock>
 </conbody></concept></concept><concept id="types-33"><title>Types</title><conbody>  <p id="33-x1">Before we jump into syntax, let's take a look at the various types involved. We
   mentioned in the introduction that types help protect us from XSS attacks. For example, let's say
   that we have an HTML template that should display someone's name; it might look like
    this:<codeblock outputclass="hamlet" id="33-x2">&lt;p&gt;Hello, my name is #{name}</codeblock><note id="33-x3"><codeph id="33-x-3">#{...}</codeph> is how we do variable interpolation in
    Shakespeare.</note></p>
  <p id="33-x4">What should happen to <varname id="33-x5">name</varname>, and what should its datatype be?
   A naive approach would be to use a <codeph id="33-x-4">Text</codeph> value, and insert it verbatim. But that
   would give us quite a problem when <codeph id="33-x6">name="&lt;script
    src='http://nefarious.com/evil.js'&gt;&lt;/script&gt;"</codeph>. What we want is to be able to
   entity-encode the name, so that <codeph id="33-x-5">&lt;</codeph> becomes <codeph id="33-x-6">&amp;lt;</codeph>.</p>
  <p id="33-x7">An equally naive approach is to simply entity-encode <b id="33-x8">every</b> piece of text
   that gets embedded. What happens when you have some preexisting HTML generated from another
   process? For example, on the Yesod website, all Haskell code snippets are run through a
   colorizing function that wraps up words in appropriate <codeph id="33-x9">span</codeph> tags. If we
   entity escaped everything, code snippets would be completely unreadable!</p>
  <p id="33-x10">Instead, we have an <codeph id="33-x-7">Html</codeph> datatype. In order to generate an
    <codeph id="33-x-8">Html</codeph> value, we have two options for APIs: the <codeph id="33-x-9">ToHtml</codeph> typeclass
   provides a way to convert <codeph id="33-x-10">String</codeph> and <codeph id="33-x-11">Text</codeph> values into
    <codeph id="33-x-12">Html</codeph>, via its <codeph id="33-x-13">toHtml</codeph> function, automatically escaping entities
   along the way. This would be the approach we'd want for the name above. For the code snippet
   example, we would use the preEscaped family of functions.</p>
  <p id="33-x11">When you use variable interpolation in Hamlet (the HTML Shakespeare language), it
   automatically applies a <codeph id="33-x-14">toHtml</codeph> call to the value inside. So if you interpolate a
    <codeph id="33-x-15">String</codeph>, it will be entity-escaped. But if you provide an <codeph id="33-x-16">Html</codeph>
   value, it will appear unmodified. In the code snippet example, we might interpolate with
   something like <codeph id="33-x12">#{preEscapedText myHaskellHtml}</codeph>.</p>
  <note id="33-x13">The <codeph id="33-x-17">Html</codeph> datatype, as well as the functions mentioned, are all
   provided by the <apiname id="33-x14">blaze-html</apiname> package. This allows Hamlet to interact
   with all other blaze-html packages, and lets Hamlet provide a general solution for producing
   blaze-html values. Also, we get to take advantage of blaze-html's amazing performance.</note>
  <p id="33-x15">Similarly, we have <codeph id="33-x-18">Css</codeph>/<codeph id="33-x-19">ToCss</codeph>, as
   well as <codeph id="33-x-20">Javascript</codeph>/<codeph id="33-x-21">ToJavascript</codeph>. These
   provide some compile-time sanity checks that we haven't accidently stuck some HTML in our
   CSS.</p>
  <note id="33-x16">One other advantage on the CSS side is some helper datatypes for colors and units.
   For example:<codeblock outputclass="lucius">.red { color: #{colorRed} }</codeblock>Please see the
   Haddock documentation for more details.</note>
 </conbody><concept id="type-safe-urls-34"><title>Type-safe URLs</title><conbody>
  <p id="34-x1">Possibly the most unique feature in Yesod is type-safe URLs, and the ability to use
   them conveniently is provided directly by Shakespeare. Usage is nearly identical to variable
   interpolation, we just use the at-sign (@) instead of the hash (#). We'll cover the syntax later;
   first, let's clarify the intuition.</p>
  <p id="34-x2">Suppose we have an application with two routes: <filepath id="34-x3">http://example.com/profile/home</filepath> is the homepage, and <filepath id="34-x4">http://example.com/display/time</filepath> displays the current time. And let's say we want to
   link from the homepage to the time. I can think of three different ways of constructing the
    URL:<ol id="34-ol_4c46dd3b-9cb4-4c02-ac0c-c70e5a19d0c5">
    <li id="34-x5">As a relative link: <filepath id="34-x6">../display/time</filepath></li>
    <li id="34-x7">As an absolute link, without a domain: <filepath id="34-x8">/display/time</filepath></li>
    <li id="34-x9">As an absolute link, with a domain: <filepath id="34-x10">http://example.com/display/time</filepath></li>
   </ol></p>
  <p id="34-x11">There are problems with each approach: the first will break if either URL changes. Also, it's
   not suitable for all use cases; RSS and Atom feeds, for instance, require absolute URLs. The
   second is more resilient to change than the first, but still won't be acceptable for RSS and
   Atom. And while the third works fine for all use cases, you'll need to update every single URL in
   your application whenever your domain name changes. You think that doesn't happen often? Just
   wait till you move from your development to staging and finally production server.</p>
  <p id="34-x12">But more importantly, there is one huge problem with all approaches: if you change your routes
   at all, the compiler won't warn you about the broken links. Not to mention that typos can wreak
   havoc as well.</p>
  <p id="34-x13">The goal of type-safe URLs is to let the compiler check things for us as much as
   possible. In order to facilitate this, our first step must be to move away from plain old text,
   which the compiler doesn't understand, to some well defined datatypes. For our simple
   application, let's model our routes with a sum
   type:<codeblock outputclass="haskell" id="34-x14">data MyRoute = Home | Time</codeblock></p>
  <p id="34-x15">Instead of placing a link like /display/time in our template, we can use the
    <codeph id="34-x-3">Time</codeph> constructor. But at the end of the day, HTML is made up of text, not data
   types, so we need some way to convert these values to text. We call this a <term id="34-x16">URL
    rendering function</term>, and a simple one
   is:<codeblock outputclass="haskell" id="34-x17">renderMyRoute :: MyRoute -&gt; Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"</codeblock></p>
  <p id="34-x18">
   <note>URL rendering functions are actually a bit more complicated than this. They need to address
    query string parameters, handle records within the constructor, and more intelligently handle
    the domain name. But in practice, you don't need to worry about this, since Yesod will
    automatically create your render functions. The one thing to point out is that the type
    signature is actually a little more complicated to handle query
    strings:<codeblock outputclass="haskell" id="34-x19">type Query = [(Text, Text)]
type Render url = url -&gt; Query -&gt; Text
renderMyRoute :: Render MyRoute
renderMyRoute Home _ = ...
renderMyRoute Time _ = ...</codeblock></note>
  </p>
  <p id="34-x20">OK, we have our render function, and we have type-safe URLs embedded in the templates.
   How does this fit together exactly? Instead of generating an <codeph id="34-x-4">Html</codeph> (or
    <codeph id="34-x-5">Css</codeph> or <codeph id="34-x-6">Javascript</codeph>) value directly, Shakespearean templates
   actually produce a function, which takes this render function and produces HTML. To see this
   better, let's have a quick (fake) peek at how Hamlet would work under the surface. Supposing we
   had a
   template:<codeblock outputclass="hamlet" id="34-x21">&lt;a href=@{Time}&gt;The time</codeblock>this
   would translate roughly into the Haskell
   code:<codeblock outputclass="haskell" id="34-x22">\render -&gt; mconcat ["&lt;a href='", render Time, "'&gt;The time&lt;/a&gt;"]</codeblock></p>
 </conbody></concept></concept><concept id="syntax-35"><title>Syntax</title><conbody>
        <p id="35-x-3">All Shakespearean languages share the same interpolation syntax, and are able to
            utilize type-safe URLs. They differ in the syntax specific for their target language
            (HTML, CSS, or Javascript).</p>
    </conbody><concept id="hamlet-syntax-36"><title>Hamlet Syntax</title><conbody>
        <p id="36-x-3">Hamlet is the most sophisticated of the languages. Not only does it provide
            syntax for generating HTML, it also allows for basic control structures: conditionals,
            looping, and maybes.</p>
    </conbody><concept id="tags-37"><title>Tags</title><conbody>  <p id="37-x1">Obviously tags will play an important part of any HTML template language. In Hamlet, we try to
   stick very close to existing HTML syntax to make the language more comfortable. However, instead
   of using closing tags to denote nesting, we use indentation. So something like this in
   HTML:<codeblock outputclass="html" id="37-x2">&lt;body&gt;
&lt;p&gt;Some paragraph.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item 1&lt;/li&gt;
&lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;</codeblock>would
   be<codeblock outputclass="hamlet" id="37-x3">&lt;body&gt;
    &lt;p&gt;Some paragraph.
    &lt;ul&gt;
        &lt;li&gt;Item 1
        &lt;li&gt;Item 2</codeblock></p>
  <p id="37-x4">In general, we find this to be easier to follow than HTML once you get accustomed to it. The
   only tricky part comes with dealing with whitespace before and after tags. For example, let's say
   you want to create the
   HTML<codeblock outputclass="html" id="37-x5">&lt;p&gt;Paragraph &lt;i&gt;italic&lt;/i&gt; end.&lt;/p&gt;</codeblock>We want to make sure
   that there is a whitespace preserved after the word "Paragraph" and before the word "end". To do
   so, we use two simple escape
   characters:<codeblock outputclass="hamlet" id="37-x6">&lt;p&gt;
    Paragraph #
    &lt;i&gt;italic
    \ end.</codeblock>The
   whitespace escape rules are actually very simple:<ol id="37-ol_kvy_tku_id">
    <li id="37-x7">If the first non-space character in a line is a backslash, the backslash is ignored.</li>
    <li id="37-x8">If the last character in a line is a hash, it is ignored.</li>
   </ol></p>
  <p id="37-x9">One other thing. Hamlet does <b id="37-x10">not</b> escape entities within its content.
   This is done on purpose to allow existing HTML to be more easily copied in. So the example above
   could also be written
   as:<codeblock outputclass="hamlet" id="37-x11">&lt;p&gt;Paragraph &lt;i&gt;italic&lt;/i&gt; end.</codeblock>Notice
   that the first tag will be automatically closed by Hamlet, while the inner "i" tag will not. You
   are free to use whichever approach you want, there is no penalty for either choice. Be aware,
   however, that the <b id="37-x-3">only</b> time you use closing tags in Hamlet is for such inline tags; normal
   tags are not closed.</p>
 </conbody></concept><concept id="interpolation-38"><title>Interpolation</title><conbody>  <p id="38-x1">What we have so far is a nice, simplified HTML, but it doesn't let us interact with our Haskell
   code at all. How do we pass in variables? Simple: with
   interpolation:<codeblock outputclass="hamlet" id="38-x2">&lt;head&gt;
    &lt;title&gt;#{title}</codeblock>The hash followed by a pair
   of braces denotes <b id="38-x3">variable interpolation</b>. In the case above, the <codeph id="38-x4">title</codeph>
   variable from the scope in which the template was called will be used. Let me state that again:
   Hamlet automatically has access to the variables in scope when it's called. There is no need to
   specifically pass variables in.</p>
  <p id="38-x5">You can apply functions within an interpolation. You can use string and numeric
   literals in an interpolation. You can use qualified modules. Both parentheses and the dollar sign
   can be used to group statements together. And at the end, the <codeph id="38-x-3">toHtml</codeph>
   function is applied to the result, meaning <i id="38-x6">any</i> instance of <codeph id="38-x-4">ToHtml</codeph> can be interpolated. Take, for instance, the following code.</p>
  
   <codeblock id="38-x9" outputclass="haskell">-- Just ignore the quasiquote stuff for now, and that shamlet thing.
-- It will be explained later.
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (shamlet)
import Text.Blaze.Renderer.String (renderHtml)
import Data.Char (toLower)
import Data.List (sort)

data Person = Person
    { name :: String
    , age  :: Int
    }

main :: IO ()
main = putStrLn $ renderHtml [shamlet|
&lt;p&gt;Hello, my name is #{name person} and I am #{show $ age person}.
&lt;p&gt;
    Let's do some funny stuff with my name: #
    &lt;b&gt;#{sort $ map toLower (name person)}
&lt;p&gt;Oh, and in 5 years I'll be #{show ((+) 5 (age person))} years old.
|]
  where
    person = Person "Michael" 26</codeblock>
  
  <p id="38-x10">What about our much-touted type-safe URLs? They are almost identical to variable
   interpolation in every way, except they start with an at-sign (@) instead. In addition, there is
   embedding via a caret (^) which allows you to embed another template of the same type. The next
   code sample demonstrates both of these.</p>
   <codeblock outputclass="haskell" id="38-x13">{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Text.Blaze.Renderer.String (renderHtml)
import Data.Text (Text)

data MyRoute = Home

render :: MyRoute -&gt; [(Text, Text)] -&gt; Text
render Home _ = "/home"

footer :: HtmlUrl MyRoute
footer = [hamlet|
&lt;footer&gt;
    Return to #
    &lt;a href=@{Home}&gt;Homepage
    .
|]

main :: IO ()
main = putStrLn $ renderHtml $ [hamlet|
&lt;body&gt;
    &lt;p&gt;This is my page.
    ^{footer}
|] render</codeblock>
 </conbody></concept><concept id="attributes-39"><title>Attributes</title><conbody>
  <p id="39-x1">In that last example, we put an href attribute on the "a" tag. Let's elaborate on the
    syntax:<ul id="39-ul_zmk_qnu_id">
    <li id="39-x2">You can have interpolations within the attribute value.</li>
    <li id="39-x3">The equals sign and value for an attribute are optional, just like in HTML. So
      <codeph id="39-x4">&lt;input type=checkbox checked&gt;</codeph> is perfectly valid.</li>
    <li id="39-x5">There are two convenience attributes: for id, you can use the hash, and for classes,
     the period. In other words, <codeph id="39-x6">&lt;p #paragraphid .class1
     .class2&gt;</codeph>.</li>
    <li id="39-x7">While quotes around the attribute value are optional, they are required if you want
     to embed spaces.</li>
    <li id="39-x8">You can add an attribute optionally by using colons. To make a checkbox only checked
     if the variable isChecked is True, you would write <codeph id="39-x9">&lt;input type=checkbox
      :isChecked:checked&gt;</codeph>. To have a paragraph be optionally red, you could use <codeph id="39-x10">&lt;p :isRed:style="color:red"&gt;</codeph>.</li>
   </ul></p>
 </conbody></concept><concept id="conditionals-40"><title>Conditionals</title><conbody>
  <p id="40-x1">Eventually, you'll want to put in some logic in your page. The goal of Hamlet is to
            make the logic as minimalistic as possible, pushing the heavy lifting into Haskell. As
            such, our logical statements are very basic... so basic, that it's <codeph id="40-x-3">if</codeph>,
                <codeph id="40-x-4">elseif</codeph>, and
            <codeph id="40-x-5">else</codeph>.<codeblock outputclass="hamlet" id="40-x2">$if isAdmin
    &lt;p&gt;Welcome to the admin section.
$elseif isLoggedIn
    &lt;p&gt;You are not the administrator.
$else
    &lt;p&gt;I don't know who you are. Please log in so I can decide if you get access.</codeblock>All
            the same rules of normal interpolation apply to the content of the conditionals.</p>
 </conbody></concept><concept id="maybe-41"><title>Maybe</title><conbody>
  <p id="41-x1">Similarly, we have a special construct for dealing with Maybe values. This could
   technically be dealt with using <codeph id="41-x-3">if</codeph>, <codeph id="41-x-4">isJust</codeph> and
    <codeph id="41-x-5">fromJust</codeph>, but this is more convenient and avoids partial
   functions.<codeblock outputclass="hamlet" id="41-x2">$maybe name &lt;- maybeName
    &lt;p&gt;Your name is #{name}
$nothing
    &lt;p&gt;I don't know your name.</codeblock>In
   addition to simple identifiers, you can use a few other, more complicated values on the left hand
   side, such as constructors and tuples.</p>
  <codeblock id="41-x-6" outputclass="hamlet">$maybe Person firstName lastName &lt;- maybePerson
    &lt;p&gt;Your name is #{firstName} #{lastName}</codeblock>
  <p id="41-x-7">The right-hand-side follows the same rules as interpolations, allow variables, function
   application, and so on.</p>
 </conbody></concept><concept id="forall-42"><title>Forall</title><conbody>
  <p id="42-x1">And what about looping over lists? We have you covered there
   too:<codeblock outputclass="hamlet" id="42-x2">$if null people
    &lt;p&gt;No people.
$else
    &lt;ul&gt;
        $forall person &lt;- people
            &lt;li&gt;#{person}</codeblock></p>
 </conbody></concept><concept id="case-43"><title>Case</title><conbody>
  <p id="43-x-3">Pattern matching is one of the great strengths of Haskell. Sum types let you cleanly model many
   real-world types, and <codeph id="43-x-4">case</codeph> statements let you safely match, letting the compiler
   warn you if you missed a case. Hamlet gives you the same power.</p>
  <codeblock id="43-x-5" outputclass="hamlet">$case foo
    $of Left bar
        &lt;p&gt;It was left: #{bar}
    $of Right baz
        &lt;p&gt;It was right: #{baz}</codeblock>
 </conbody></concept><concept id="with-44"><title>With</title><conbody>  <p id="44-x1">Rounding out our statements, we have <codeph id="44-x-3">with</codeph>. It's basically just a
            convenience for declaring a synonym for a long
            expression.<codeblock outputclass="hamlet" id="44-x2">$with foo &lt;- some very (long ugly) expression that $ should only $ happen once
    &lt;p&gt;But I'm going to use #{foo} multiple times. #{foo}</codeblock></p>
 </conbody></concept><concept id="doctype-45"><title>Doctype</title><conbody>
  <p id="45-x1">Last bit of syntactic sugar: the doctype statement. We have support for a number of
            different versions of a <codeph id="45-x-3">doctype</codeph>, though we recommend <codeph id="45-x-4">$doctype
                5</codeph> for modern web applications, which generates <codeph id="45-x2">&lt;!DOCTYPE
                html&gt;</codeph>.<codeblock outputclass="hamlet" id="45-x3">$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hamlet is Awesome
    &lt;body&gt;
        &lt;p&gt;All done.</codeblock><note id="45-x-5">There
                is an older and still supported syntax: three exclamation points
                    (<codeph id="45-x-6">!!!</codeph>). You may still see this in code out there. We have no
                plans to remove support for this, but in general find the <codeph id="45-x-7">$doctype</codeph>
                approach easier to read.</note></p>
 </conbody></concept></concept><concept id="cassius-syntax-46"><title>Cassius Syntax</title><conbody>
  <p id="46-x1">Cassius is the original CSS template language. It uses simple whitespace rules to delimit
   blocks, making braces and semicolons unnecessary. It supports both variable and URL
   interpolation, but not embedding. The syntax is very
   straight-forward:<codeblock outputclass="cassius" id="46-x2">#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})</codeblock></p>
 </conbody></concept><concept id="lucius-syntax-47"><title>Lucius Syntax</title><conbody>
  <p id="47-x1">While Cassius uses a modified, whitespace-sensitive syntax for CSS, Lucius is true to
   the original. You can take any CSS file out there and it will be a valid Lucius file. There are,
   however, a few additions to Lucius:<ul id="47-ul_a847e33f-f3af-4fe1-9a3b-d7b2353921f7">
    <li id="47-x2">Like Cassius, we allow both variable and URL interpolation.</li>
    <li id="47-x3">CSS blocks are allowed to nest.</li>
    <li id="47-x-3">You can declare variables in your templates.</li>
   </ul></p>
  <p id="47-x4">Starting the with second point: let's say you want to have some special styling for
   some tags within your <codeph id="47-x5">article</codeph>. In plain ol' CSS, you'd have to
   write:<codeblock outputclass="css" id="47-x6">article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }</codeblock>In
   this case, there aren't that many clauses, but having to type out article each time is still a
   bit of a nuisance. Imagine if you had a dozen or so of these. Not the worst thing in the world,
   but a bit of an annoyance. Lucius helps you out
   here:<codeblock outputclass="lucius" id="47-x7">article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
}</codeblock></p>
  <p id="47-x-4">Having Lucius variables allows you to avoid repeating yourself. A simple example would be to
   define a commonly used color:</p>
  <codeblock id="47-x-5" outputclass="lucius">@textcolor: #ccc; /* just because we hate our users */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }</codeblock>
  <p id="47-x8">Other than that, Lucius is identical to CSS.</p>
 </conbody></concept><concept id="julius-syntax-48"><title>Julius Syntax</title><conbody>
  <p id="48-x1">Julius is the simplest of the languages discussed here. In fact, some might even say
   it's really just Javascript. Julius allows the three forms of interpolation we've mentioned so
   far, and otherwise applies no transformations to your content.<note id="48-x2">If you use Julius
    with the scaffolded Yesod site, you may notice that your Javascript is automatically minified.
    This is not a feature of Julius; instead, Yesod uses the <apiname id="48-x3">hjsmin</apiname>
    package to minify Julius output.</note></p>
 </conbody></concept></concept><concept id="calling-shakespeare-49"><title>Calling Shakespeare</title><conbody>  <p id="49-x1">The question of course arises at some point: how do I actually use this stuff? There are three
   different ways to call out to Shakespeare from your Haskell code:</p>
  <dl id="49-x2">
   <dlentry id="49-x3">
    <dt id="49-x4">Quasiquotes</dt>
    <dd id="49-x5">Quasiquotes allow you to embed arbitrary content within your Haskell, and for it to be
     converted into Haskell code at compile time.</dd>
   </dlentry>
   <dlentry id="49-x6">
    <dt id="49-x7">External file</dt>
    <dd id="49-x8">In this case, the template code is in a separate file which is referenced via Template
     Haskell.</dd>
   </dlentry>
   <dlentry id="49-x9">
    <dt id="49-x10">Reload mode</dt>
    <dd id="49-x11">Both of the above modes require a full recompile to see any changes. In reload
     mode, your template is kept in a separate file and referenced via Template Haskell. But at
     runtime, the external file is reparsed from scratch each time.<note id="49-x12">Reload mode is not
      available for Hamlet, only for Cassius, Lucius and Julius. There are too many sophisticated
      features in Hamlet that rely directly on the Haskell compiler and could not feasible be
      reimplemented at runtime.</note></dd>
   </dlentry>
  </dl>
  <p id="49-x13">One of the first two approaches should be used in production. They both embed the entirety of
   the template in the final executable, simplifying deployment and increasing performance. The
   advantage of the quasiquoter is the simplicity: everything stays in a single file. For short
   templates, this can be a very good fit. However, in general, the external file approach is
   recommended because:<ul id="49-ul_bbc_seu_id">
    <li id="49-x14">It follows nicely in the tradition of separate logic from presentation.</li>
    <li id="49-x15">You can easily switch between external file and debug mode with some simple CPP macros,
     meaning you can keep rapid development and still achieve high performance in production.</li>
   </ul></p>
  <p id="49-x16">Since these are special QuasiQuoters and Template Haskell functions, you need to be
   sure to enable the appropriate language extensions and use correct syntax. You can see a simple
   example of each in the figures.</p>
  <fig id="49-x17">
   <title id="49-x18">Quasiquoter</title>
   <codeblock id="49-x19" outputclass="haskell">{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Data.Text (Text)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -&gt; [(Text, Text)] -&gt; Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: Text -&gt; HtmlUrl MyRoute
template title = [hamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{title}
        &lt;link rel=stylesheet href=@{Stylesheet}&gt;
    &lt;body&gt;
        &lt;h1&gt;#{title}
|]

main :: IO ()
main = putStrLn $ renderHtml $ template "My Title" render</codeblock>
  </fig>
  <fig id="49-x20">
   <title id="49-x21">External file</title>
   <codeblock id="49-x22" outputclass="haskell">{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- to control production versus debug
import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -&gt; [(Text, Text)] -&gt; Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render</codeblock>
   <codeblock outputclass="lucius" id="49-x51">-- @template.lucius
foo { bar: baz }</codeblock>
  </fig>
  <p id="49-x23">The naming scheme for the functions is very consistent.</p>
  <simpletable id="49-simpletable_kvg_tgu_id">
   <sthead id="49-x24">
    <stentry id="49-x25">Language</stentry>
    <stentry id="49-x26">Quasiquoter</stentry>
    <stentry id="49-x27">External file</stentry>
    <stentry id="49-x28">Reload</stentry>
   </sthead>
   <strow id="49-x29">
    <stentry id="49-x30">Hamlet</stentry>
    <stentry id="49-x31"><apiname id="49-x50">hamlet:Text.Hamlet:hamlet</apiname></stentry>
    <stentry id="49-x32"><codeph id="49-x-3">hamletFile</codeph></stentry>
    <stentry id="49-x33"><i id="49-x34">N/A</i></stentry>
   </strow>
   <strow id="49-x35">
    <stentry id="49-x36">Cassius</stentry>
    <stentry id="49-x37"><codeph id="49-x-4">cassius</codeph></stentry>
    <stentry id="49-x38"><codeph id="49-x-5">cassiusFile</codeph></stentry>
    <stentry id="49-x39"><codeph id="49-x-6">cassiusFileReload</codeph></stentry>
   </strow>
   <strow id="49-x40">
    <stentry id="49-x41">Lucius</stentry>
    <stentry id="49-x42"><codeph id="49-x-7">lucius</codeph></stentry>
    <stentry id="49-x43"><codeph id="49-x-8">luciusFile</codeph></stentry>
    <stentry id="49-x44"><codeph id="49-x-9">luciusFileReload</codeph></stentry>
   </strow>
   <strow id="49-x45">
    <stentry id="49-x46">Julius</stentry>
    <stentry id="49-x47"><codeph id="49-x-10">julius</codeph></stentry>
    <stentry id="49-x48"><codeph id="49-x-11">juliusFile</codeph></stentry>
    <stentry id="49-x49"><codeph id="49-x-12">juliusFileReload</codeph></stentry>
   </strow>
  </simpletable>
 </conbody><concept id="alternate-hamlet-types-50"><title>Alternate Hamlet Types</title><conbody>
  <p id="50-x1">So far, we've seen how to generate an <codeph id="50-x2">HtmlUrl</codeph> value from Hamlet, which is a
   piece of HTML with embedded type-safe URLs. There are currently three other values we can
   generate using Hamlet: plain HTML, HTML with URLs <b id="50-x3">and</b> internationalized messages, and
   widgets. That last one will be covered in the widgets chapter.</p>
  <p id="50-x4">To generate plain HTML without any embedded URLs, we use "simplified Hamlet". There are a few
    changes:<ul id="50-ul_ker_khu_id">
    <li id="50-x5">We use a different set of functions, prefixed with an "s". So the quasiquoter is
      <codeph id="50-x6">shamlet</codeph> and the external file function is <codeph id="50-x7">shamletFile</codeph>. How
     we pronounce those is still up for debate.</li>
    <li id="50-x8">No URL interpolation is allowed. Doing so will result in a compile-time error.</li>
    <li id="50-x9">Embedding (the caret-interpolator) no longer allows arbitrary <codeph id="50-x10">HtmlUrl</codeph> values. The rule is that the embedded value must have the same type as the
     template itself, so in this case it must be <codeph id="50-x11">Html</codeph>. That means that for
      <codeph id="50-x-3">shamlet</codeph>, embedding can be completely replaced with normal variable
     interpolation (with a hash).</li>
   </ul></p>
  <p id="50-x12">Dealing with internationalization (i18n) in Hamlet is a bit complicated. Hamlet
   supports i18n via a message datatype, very similar in concept and implementation to a type-safe
   URL. As a motivating example, let's say we want to have an application that tells you hello and
   how many apples you have eaten. We could represent those messages with a
   datatype.<codeblock id="50-x13" outputclass="haskell">data Msg = Hello | Apples Int</codeblock>Next,
   we would want to be able to convert that into something human-readable, so we define some render
   functions:<codeblock outputclass="haskell" id="50-x14">renderEnglish :: Msg -&gt; Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought ", T.pack $ show i, " apples."]</codeblock>Now
   we want to interpolate those Msg values directly in the template. For that, we use underscore
   interpolation.<codeblock outputclass="hamlet" id="50-x15">$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;i18n
    &lt;body&gt;
        &lt;h1&gt;_{Hello}
        &lt;p&gt;_{Apples count}</codeblock></p>
  <p id="50-x16">This kind of a template now needs some way to turn those values into HTML. So just
   like type-safe URLs, we pass in a render function. To represent this, we define a new type
   synonym:<codeblock outputclass="haskell" id="50-x17">type Render url = url -&gt; [(Text, Text)] -&gt; Text
type Translate msg = msg -&gt; Html
type HtmlUrlI18n msg url = Translate msg -&gt; Render url -&gt; Html</codeblock>At
   this point, you can pass <codeph id="50-x-4">renderEnglish</codeph>, <codeph id="50-x-5">renderSpanish</codeph>, or <codeph id="50-x-6">renderKlingon</codeph> to this template, and it
   will generate nicely translated output (depending, of course, on the quality of your
   translators). The complete program is:</p>
  <codeblock outputclass="haskell" id="50-x20">{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Data.Text (Text)
import qualified Data.Text as T
import Text.Hamlet (HtmlUrlI18n, ihamlet)
import Text.Blaze (toHtml)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

renderUrl :: MyRoute -&gt; [(Text, Text)] -&gt; Text
renderUrl Home _ = "/home"
renderUrl Time _ = "/time"
renderUrl Stylesheet _ = "/style.css"

data Msg = Hello | Apples Int

renderEnglish :: Msg -&gt; Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought ", T.pack $ show i, " apples."]

template :: Int -&gt; HtmlUrlI18n Msg MyRoute
template count = [ihamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;i18n
    &lt;body&gt;
        &lt;h1&gt;_{Hello}
        &lt;p&gt;_{Apples count}
|]

main :: IO ()
main = putStrLn $ renderHtml
     $ (template 5) (toHtml . renderEnglish) renderUrl</codeblock>
 </conbody></concept></concept><concept id="other-shakespeare-51"><title>Other Shakespeare</title><conbody>
  <p id="51-x-3">In addition to HTML, CSS and Javascript helpers, there is also some more general-purpose
   Shakespeare available. <apiname id="51-x-4">shakespeare-text</apiname> provides a simple way to create
   interpolated strings, much like people are accustomed to in scripting languages like Ruby and
   Python. This package's utility is definitely not limited to Yesod.</p>
  <codeblock id="51-x-5" outputclass="haskell">{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}
import Text.Shakespeare.Text
import qualified Data.Text.Lazy.IO as TLIO
import Data.Text (Text)
import Control.Monad (forM_)

data Item = Item
    { itemName :: Text
    , itemQty :: Int
    }

items :: [Item]
items =
    [ Item "apples" 5
    , Item "bananas" 10
    ]

main :: IO ()
main = forM_ items $ \item -&gt; TLIO.putStrLn
    [lt|You have #{show $ itemQty item} #{itemName item}.|]</codeblock>
  <p id="51-x-6">Some quick points about this simple example:</p>
  <ul id="51-ul_dts_rzy_ae">
   <li id="51-x-7">Notice that we have three different textual datatypes involved
     (<codeph id="51-x-11">String</codeph>, strict <codeph id="51-x-12">Text</codeph> and lazy <codeph id="51-x-13">Text</codeph>). They
    all play together well.</li>
   <li id="51-x-8">We use a quasiquoter named <codeph id="51-x-9">lt</codeph>, which generates lazy text. There is also
     <codeph id="51-x-10">st</codeph>.</li>
   <li>Also, there are longer names for these quasiquoters (<codeph>ltext</codeph> and
     <codeph>stext</codeph>).</li>
  </ul>
 </conbody></concept><concept id="general-recommendations-52"><title>General Recommendations</title><conbody><p id="52-x1">Here are some general hints from the Yesod community on how to get the most out of
                                                  Shakespeare.</p>
<ul id="52-x2">
<li id="52-x3">For actual sites, use external files. For libraries, it's OK to use quasiquoters, assuming they aren't too long.</li>
<li id="52-x4">Patrick Brisbin has put together a <xref id="52-x5" scope="external" href="https://github.com/pbrisbin/html-template-syntax" format="html">Vim code
                    highlighter</xref> that can help out immensely.</li>
<li id="52-x6">You should almost always start Hamlet tags on their own line instead of embedding
                                                  start/end tags after an existing tag. The only
                                                  exception to this is the occasional
                                                  <codeph id="52-x-3">&lt;i&gt;</codeph> or
                                                  <codeph id="52-x-4">&lt;b&gt;</codeph> tag inside a large
                                                  block of text.</li>
</ul></conbody></concept></concept>